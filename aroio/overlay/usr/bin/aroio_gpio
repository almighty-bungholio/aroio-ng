#!/bin/python

from RPi import GPIO
from time import sleep
import subprocess
import threading
import os

Enc_A = 0 # Not all aroios have a rotary encoder, so we are disabling it
Enc_B = 0 #   by initializing it with pin 0
Btn_Pause = 27
LED_Net = 22

# Setting up a null device
FNULL = open(os.devnull, 'w')

# Access to userconfig variables
config = {}
with open("/boot/userconfig.txt") as f:
    for line in f:
        try:
            key,value = line.strip().split("=",1)
        except ValueError:
            print("Incorrect line in config: ", line)
        config[key] = value[1:-1]

# Set initial volume to prevent jump upon first usage of rotary encoder

Volume = int(config["VOLUME_START"])

#AmixerVolume = int(subprocess.Popen(["amixer sget Master | awk '/Left:/ { print $3 }'"], shell=True,stdout=subprocess.PIPE).communicate()[0].decode('utf-8'))
#print (AmixerVolume)

# VOLalsa = (VOLjack*3,1875)+255

oldVolume = 0
A_LastState = 0

# Check if platform has a rotary encoder and assign GPIOs
if str(config["PLATFORM"]) == "AroioLT":
    Enc_A = 23
    Enc_B = 24
    LED_net = 22

# Initializing our GPIOs
GPIO.setmode(GPIO.BCM)
GPIO.setup(Enc_A, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(Enc_B, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(Btn_Pause, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(LED_Net, GPIO.OUT)

# Callback function that decodes our rotary encoder
def rotation_decode(Enc_A):
    global Volume
    global A_LastState

    A_State = GPIO.input(Enc_A)
    B_State = GPIO.input(Enc_B)

    if A_State != A_LastState:
        if A_State != B_State:
            Volume -= 3
        else:
            Volume += 3

    if Volume > -1:
        Volume = 0

    if Volume < -80:
        Volume = -80

    A_LastState = A_State

# Callback function that controls our LMS server: pause
def pause_alert(input):
    #print("Button Pause was pushed!")
    subprocess.call(["aroio_control_lms", "pause"])

# Callback function that controls our LED
def control_led(state):
    print("Turning LED", state)
    if str(state) == "on":
        GPIO.output(LED_net, 1)
    else:
        GPIO.output(LED_net, 0)

# Attach events to our pins
GPIO.add_event_detect(Enc_A, GPIO.BOTH, callback=rotation_decode, bouncetime=2)
GPIO.add_event_detect(Btn_Pause,GPIO.RISING,callback=pause_alert, bouncetime=200)

# Main loop
try:
    while True:
        sleep(0.01)
        if Volume != oldVolume:
            AlsaVolume = Volume * 3.1875 + 255
            print(Volume)
            print(AlsaVolume)
            threading.Thread(target=lambda ctr: subprocess.call(["volumecontrol", str(ctr)], stdout=FNULL, stderr=subprocess.STDOUT), args=(Volume,)).start()
            threading.Thread(target=lambda ctr: subprocess.call(["amixer", "sset", "'Master'", str(ctr)], stdout=FNULL, stderr=subprocess.STDOUT), args=(AlsaVolume,)).start()
            oldVolume = Volume
            f = open("/tmp/volume", "w")
            f.write(str(Volume))

# Try to exit clean
except KeyboardInterrupt:
    GPIO.remove_event_detect(Enc_A)
    GPIO.remove_event_detect(Enc_B)
    GPIO.remove_event_detect(Btn_Pause)
    GPIO.cleanup()
